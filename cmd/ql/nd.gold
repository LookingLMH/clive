package main

import (
	"bytes"
	"fmt"
	"io"
	"strings"
	"clive/cmd"
)

// We could have used a series of 
type NdType int

// we use (...) to mean args and {...} to mean children nodes
//
// Nname[NAME]			x
// Nval[NAME]			$x
// Nval[NAME]{name}			$x[a]
// Nsingle[NAME]			$^a
// Nsingle[NAME]{name}		$^a[b]
// Nset[name]{names}		x = ...
// Nset[name]{name, names}		x[n] = ...
// Nlen[NAME]			$#a
// Napp{names, names}		( .... ) ^ ( ...)
// Nmap{names, ....}			([a b c] [d e])
// Nioblk["<|>", NAME]{pipe,..., redirs}		<[x]{a b c} >[x]{a b c}
// Nioblk["<"]{pipe,..., redirs}			<{a b c}
// Nnames{name|app|len|single|val|map|ioblk| ....}	a b c
// Nredir["<|>|>>" NAME]{name}		<[a,x] b
// Nredir["<"]				| a ...
// Nredirs{redir...}
//
// Ncmd{names, redirs}		a b c <d >e ...
// Npipe[bg,pipe0,pipe1...]{cmd|set|cond|while|for|block,...}
				a |[x] b | c &y -> [y,x,]{a, b, c}
// Nblock{pipe,..., redirs}		{ a ; b } > a
// Nfor{names, block, redirs}		for a b { ... } <a
// Nwhile{pipe, block, redirs}		while pipe { ... } <a
// Nfunc[NAME]{pipe...}		func a { ... }
// Ncond{or...}			cond { ... } or {... } ... or {...}
// Nor{pipe...}
// Nsrc{name}			source, < name
const (
	Nnone NdType = iota
	Nname
	Nval
	Nset
	Nsingle
	Nlen
	Napp
	Nnames
	Nmap
	Nredir
	Nredirs
	Ncmd
	Npipe
	Nblock
	Nfor
	Nwhile
	Nfunc
	Ncond
	Nor
	Nioblk
	Nsrc
)

struct NdAddr {
	File string
	Ln   int
}

struct Nd {
	typ   NdType
	Args  []string
	Child []*Nd
	NdAddr
}

func newNd(typ NdType, args ...string) *Nd {
	nd := &Nd{typ: typ, Args: args}
	nd.NdAddr = NdAddr{yylex.rdr.Name(), yylex.Line}
	return nd
}

func newList(typ NdType, child ...*Nd) *Nd {
	for i := range child {
		if child[i] == nil {
			child[i] = &Nd{} // safety
		}
	}
	nd := &Nd{typ: typ, Child: child}
	nd.NdAddr = NdAddr{yylex.rdr.Name(), yylex.Line}
	return nd
}

func (nd *Nd) Add(child ...*Nd) *Nd {
	nd.Child = append(nd.Child, child...)
	return nd
}

// Called to add a redir to stdin in | ... pipes
func (nd *Nd) addInRdr() {
	if nd == nil || nd.typ != Npipe {
		cmd.Dprintf("addinrdr: nil nd or not a pipe\n")
		panic(parseErr)	// recovered at top-level
	}
	if len(nd.Child) == 0 {
		cmd.Dprintf("addinrdr: no command 0\n")
		panic(parseErr)	// recovered at top-level
	}
	c := nd.Child[0]
	if len(c.Child) == 0 {
		cmd.Dprintf("addinrdr: child without children\n")
		panic(parseErr)	// recovered at top-level
	}
	rdr := c.Child[len(c.Child)-1]
	if rdr.typ != Nredirs {
		cmd.Dprintf("addinrdr: child without redirs\n")
		panic(parseErr)	// recovered at top-level
	}
	in := newNd(Nredir, "<")
	rdr.Child = append(rdr.Child, in)
}

func (t NdType) String() string {
	switch t {
	case Nnone:
		return "none"
	case Nname:
		return "name"
	case Nval:
		return "val"
	case Nset:
		return "set"
	case Nsingle:
		return "single"
	case Nlen:
		return "len"
	case Napp:
		return "app"
	case Nnames:
		return "names"
	case Nmap:
		return "map"
	case Nredir:
		return "redir"
	case Nredirs:
		return "redirs"
	case Ncmd:
		return "cmd"
	case Npipe:
		return "pipe"
	case Nblock:
		return "block"
	case Nfor:
		return "for"
	case Nwhile:
		return "while"
	case Nfunc:
		return "func"
	case Ncond:
		return "cond"
	case Nor:
		return "or"
	case Nioblk:
		return "ioblk"
	case Nsrc:
		return "source"
	default:
		return fmt.Sprintf("BADTYPE<%d>", t)
	}
}

// debug only
func (n *Nd) String() string {
	if n == nil {
		return "<nil nd>"
	}
	return fmt.Sprintf("%s", n.typ)
}

// debug
func (n *Nd) writeTo(w io.Writer, lvl int) {
	pref := strings.Repeat("    ", lvl)
	fmt.Fprintf(w, "%s%s", pref, n)
	if len(n.Args) > 0 {
		fmt.Fprintf(w, "(")
		sep := ""
		for _, a := range n.Args {
			fmt.Fprintf(w, "%s%s", sep, a)
			sep = ", "
		}
		fmt.Fprintf(w, ")")
	}
	if len(n.Child) == 0 {
		fmt.Fprintf(w, "\n")
		return
	}
	fmt.Fprintf(w, " {\n")
	for _, c := range n.Child {
		c.writeTo(w, lvl+1)
	}

	fmt.Fprintf(w, "%s}\n", pref)
}

// debug
struct dnd {
	*Nd
}

func (d dnd) String() string {
	var buf bytes.Buffer
	d.writeTo(&buf, 0)
	return buf.String()
}
